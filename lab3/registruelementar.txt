Registru.v
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 10/29/2025 07:51:04 AM
// Design Name: 
// Module Name: registru elementar
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module registruelementar(
  input clk,
  input rst_n,
  input we,
  input oe,
  
  input[7:0] data_in,
  output [7:0]data_out,
  output [7:0]disp_out
    );
    reg[7:0]mem;
    
    always@(posedge clk)begin
    if(!rst_n )begin
    mem<={8{1'b0}};
        end else if(we) begin
    mem<=data_in;
        end
    end
    assign disp_out =mem;
    assign data_out =oe?mem:{8{1'b0}};
endmodule

TestBench
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 10/29/2025 07:51:04 AM
// Design Name: 
// Module Name: registru elementar
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

module Register_tb;

    // Definim lățimea de date pentru a corespunde modulului Register
    localparam DATA_WIDTH = 8;
    localparam CLK_PERIOD = 10; // Perioada ceasului (10ns -> Frecvență 100MHz)

    // Semnale pentru test bench (Intrările modulului Register)
    reg clk;
    reg rst_n;
    reg we;
    reg oe;
    reg [DATA_WIDTH-1:0] data_in;

    // Fire pentru ieșirile modulului Register
    wire [DATA_WIDTH-1:0] data_out;
    wire [DATA_WIDTH-1:0] disp_out;

    // Instanțierea modulului sub test (DUT - Device Under Test)
    Register #(
        .DATA_WIDTH(DATA_WIDTH)
    ) DUT (
        .clk(clk),
        .rst_n(rst_n),
        .we(we),
        .oe(oe),
        .data_in(data_in),
        .data_out(data_out),
        .disp_out(disp_out)
    );

    // Generarea Ceasului
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk; // Comută la jumătate de perioadă
    end

    // Secvența de Test
    initial begin
        // Inițializare și Reset
        $display("------------------------------------------------------------------");
        $display("Incepere simulare Test Bench pentru modulul Register");
        
        rst_n = 0;   // Activează Reset
        we    = 0;
        oe    = 0;
        data_in = 8'hAA; // Valoare inițială de intrare

        #(CLK_PERIOD * 2); // Așteaptă 2 cicluri de ceas pentru Reset Sincron
        
        // Verificare Reset
        $display("T=%0t | STARE: RESET. disp_out (valoarea memorata) ar trebui sa fie 0x00.", $time);
        rst_n = 1;   // Dezactivează Reset
        
        // 1. Primul test: Scrierea unei valori (Sincron, we=1)
        we = 1;
        oe = 1;
        data_in = 8'hC5;
        #(CLK_PERIOD); // Așteaptă un front crescător
        
        // Verificare Stocare (la frontul crescător al ceasului anterior)
        $display("T=%0t | STARE: SCRIS 0xC5. disp_out = 0x%h, data_out = 0x%h", $time, disp_out, data_out);
        
        // 2. Al doilea test: Menținerea valorii (we=0)
        we = 0;
        data_in = 8'hFF; // Schimbă intrarea, dar nu scrie
        #(CLK_PERIOD * 2); // Așteaptă 2 cicluri
        
        // Verificare Hold
        $display("T=%0t | STARE: HOLD. disp_out ar trebui sa ramana 0xC5. disp_out = 0x%h, data_out = 0x%h", $time, disp_out, data_out);

        // 3. Al treilea test: Verificare Output Enable (oe) - Asincron
        
        // Cazul A: oe=0 (data_out ar trebui să fie 0)
        oe = 0;
        #5; // Așteaptă 5ns (în mijlocul ciclului, Asincron)
        $display("T=%0t | STARE: OE=0. data_out ar trebui sa fie 0x00. data_out = 0x%h", $time, data_out);
        
        // Cazul B: oe=1 (data_out ar trebui să fie valoarea memorată 0xC5)
        oe = 1;
        #5; // Așteaptă 5ns (Asincron)
        $display("T=%0t | STARE: OE=1. data_out ar trebui sa fie 0xC5. data_out = 0x%h", $time, data_out);
        
        // 4. Al patrulea test: Scrierea unei noi valori și control oe
        we = 1;
        data_in = 8'h3A;
        
        // Așteaptă 0.5 ciclu
        #(CLK_PERIOD/2);
        
        // Test Asincron in timp ce scrierea este pregătită
        oe = 0;
        $display("T=%0t | STARE: Scriere 0x3A, OE=0. data_out = 0x%h, disp_out = 0x%h", $time, data_out, disp_out);
        
        // Așteaptă frontul crescător (scriere)
        #(CLK_PERIOD/2);
        
        // Verificare scriere (disp_out ar trebui să fie 0x3A)
        $display("T=%0t | STARE: Scriere efectuata. disp_out = 0x%h", $time, disp_out);
        
        // Verificare oe=0
        $display("T=%0t | STARE: OE=0 mentinut. data_out = 0x%h", $time, data_out);

        // Activează oe
        oe = 1;
        #5;
        $display("T=%0t | STARE: OE=1. data_out ar trebui sa fie 0x3A. data_out = 0x%h", $time, data_out);
        
        // Finalizare
        #(CLK_PERIOD);
        $display("------------------------------------------------------------------");
        $display("Simulare incheiata.");
        $finish;
    end
    
endmodule